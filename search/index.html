<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="Search - https://idiots-dream.github.io/search/">
    <meta name="author" content="漠河 - https://idiots-dream.github.io">
    
    <meta name="msvalidate.01" content="B46311949B856F2A7015F366FB3CE878" />
    <title>Search</title>
    <link rel="icon" type="image/png" href="/favicon.ico">
    
    <link rel="stylesheet" href="https://idiots-dream.github.io/style.min.d252ad53a5e6b2ae6b8c6c1661107189be3668e36c8dd61697bbe008595a7e04.css">
    
    <script type="text/javascript" src="/main.js" defer></script>
    
</head>
<body class="active-animate cool">
        <div id="header"><div class="container-header">
    <div id="vars" class="container-vars" style="display: none;">
	{
		"isSingleColumnOfPostList": true,
		"hasFoldAllCodeBlocks": false,
		"svgColor": "",
		"en": false,
		"dark": true
	}
</div>
    <h1 class="title">
        
            搜索
            
        
    </h1>

    <div class="container-breadcrumb-nav">
    
    <div class="breadcrumb-nav-bar">
        <div><a href="/"><svg t="1656411084410" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2954" width="16" height="16"><path d="M947.5 390.6l-377-290c-34.5-26.5-82.6-26.5-117.1 0l-377 290c-14 10.8-16.6 30.9-5.9 44.9 10.8 14 30.9 16.6 44.9 5.9l28.5-21.9V768c0 88.2 71.8 160 160 160h80c35.3 0 64-28.7 64-64V640c0-17.6 14.4-32 32-32h64c17.6 0 32 14.4 32 32v224c0 35.3 28.7 64 64 64h80c88.2 0 160-71.8 160-160V419.4l28.5 21.9c5.8 4.5 12.7 6.6 19.5 6.6 9.6 0 19.1-4.3 25.4-12.5 10.8-13.9 8.2-34-5.8-44.8zM816 768c0 52.9-43.1 96-96 96h-80V640c0-52.9-43.1-96-96-96h-64c-52.9 0-96 43.1-96 96v224h-80c-52.9 0-96-43.1-96-96V370.2l284.5-218.8c11.5-8.8 27.5-8.8 39 0L816 370.2V768z" fill="#6c757d" p-id="2955"></path></svg></a></div>
        <div><a href="/nav"><svg t="1656411531924" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5827" width="16" height="16"><path d="M849.59197473 125.23018519L139.22930586 391.72854662a23.35052669 23.35052669 0 0 0-14.95414244 21.65490745c-0.12257519 9.70384955 5.61801843 18.46795771 14.40255493 22.04306141l318.42928099 129.25528056 119.51057092 320.39047893c3.06437293 8.23295069 10.35758221 13.89182751 18.7335381 14.87242563l2.7170774 0.14300521a22.79893918 22.79893918 0 0 0 21.20546682-15.36272638l259.51158924-729.54564933a23.8612558 23.8612558 0 0 0-5.31158128-24.55584682 22.3290685 22.3290685 0 0 0-23.9021142-5.43415649zM793.65694081 211.64552314l-196.63064161 552.75171747-91.91077952-246.37564122-253.62799211-102.96295445 542.16941324-203.4131218z" p-id="5828" fill="#6c757d"></path></svg></a></div>
        <div><a href="/search"><svg t="1656411627509" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1730" width="14" height="14"><path d="M469.333333 85.333333c211.968 0 384 172.032 384 384s-172.032 384-384 384-384-172.032-384-384 172.032-384 384-384z m0 682.666667c164.992 0 298.666667-133.674667 298.666667-298.666667 0-165.034667-133.674667-298.666667-298.666667-298.666666-165.034667 0-298.666667 133.632-298.666666 298.666666 0 164.992 133.632 298.666667 298.666666 298.666667z m362.026667 3.029333l120.704 120.661334-60.373333 60.373333-120.661334-120.704 60.330667-60.330667z" p-id="1731" fill="#6c757d"></path></svg></a></div>
        <div><a href="/posts"><svg t="1656411724198" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5655" width="12" height="12"><path d="M811.705761 1024H212.294239c-93.1199 0-174.823046-87.570975-174.823046-187.387854V162.322018C37.471193 69.776145 112.604921 0 212.294239 0H596.190595l7.015883 5.93161c111.74388 95.479788 185.857116 170.741078 279.614824 266.093304 29.65805 30.040735 61.165743 62.122454 96.436499 97.393211l7.271006 7.334787v459.859234c-0.063781 99.816879-81.703145 187.387854-174.823046 187.387854zM212.294239 49.94033c-72.391155 0-124.882716 47.261538-124.882716 112.381688v674.290128c0 71.94469 59.507443 137.383743 124.882716 137.383743h599.411522c65.311492 0 124.882716-65.439053 124.882716-137.383743V397.417876c-32.528184-32.464404-61.73977-62.250016-89.356836-90.377328-90.951355-92.418312-163.278729-165.957521-269.601245-257.163999H212.294239z" fill="#6c757d" p-id="5656"></path><path d="M936.588477 449.526752h-212.326129c-99.753099 0-187.324073-81.703145-187.324073-174.823046V49.94033a25.002055 25.002055 0 0 1 49.94033 0v224.763376c0 65.311492 65.502834 124.882716 137.383743 124.882716h212.326129a25.002055 25.002055 0 1 1 0 49.94033z" fill="#6c757d" p-id="5657"></path></svg></a></div>
        <div><a href="/archive"><svg t="1656411795742" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7334" width="12" height="12"><path d="M884.224 522.24H504.32V141.824c0-16.896-13.824-30.72-30.72-30.72-120.32 0-233.472 47.616-317.952 134.144S26.112 445.952 29.184 566.784c2.56 114.688 49.152 222.72 131.072 304.128 81.92 81.408 189.952 128 304.64 130.56h10.24c117.76 0 227.84-45.568 312.32-128.512 86.528-85.504 133.632-199.68 132.608-321.024-0.512-2.048-1.536-29.696-35.84-29.696z m-140.288 307.712c-74.752 73.728-173.056 112.64-277.504 110.592-205.824-4.608-370.688-169.472-375.296-374.784-3.072-104.448 35.84-202.752 108.544-277.504 65.536-67.072 151.552-107.52 243.712-114.688v378.88c0 16.896 13.824 30.72 30.72 30.72 129.024 0 311.296 0 382.976 0.512-6.144 93.184-46.08 179.712-113.152 246.272z" fill="#6c757d" p-id="7335"></path><path d="M603.136 11.264c-8.192-0.512-15.872 3.072-22.016 8.704-5.632 5.632-9.216 13.824-9.216 22.016v378.88c0 16.896 13.824 30.72 30.72 30.72h378.88c16.896 0 30.72-13.824 30.72-30.72 0-223.744-183.808-407.552-409.088-409.6z m30.208 378.88V74.24c167.424 16.384 301.056 150.016 315.904 315.904h-315.904z" fill="#6c757d" p-id="7336"></path></svg></a></div>
        <div id="light-dark" style="cursor: pointer;"><a><svg t="1656411842215" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5086" width="12" height="12"><path d="M1007.492874 384.513055c-8.795694-34.58307-21.189627-67.666874-36.682043-99.05151-2.698679-5.397358-10.894667-3.498287-10.894666 2.598728v0.299853c0 32.484098-6.896624 63.868734-19.890263 92.554691-10.694764 23.488501-25.487523 45.077933-43.978471 64.068635-41.779547 42.679107-99.05151 66.967217-158.722299 67.26707-61.869712 0.299853-119.941284-24.188159-162.920244-68.966238-40.280281-41.979449-62.56937-98.251902-62.269516-156.323473 0.399804-59.270984 23.588452-114.94373 65.567901-156.823229 19.59041-19.59041 42.179351-35.082826 66.667364-46.077443C672.956643 71.166451 704.041426 64.469729 736.125719 64.469729h1.299364c6.097015 0 8.096037-8.096037 2.598728-10.794715C708.739126 37.982696 675.655322 25.488812 641.172203 16.493216 599.492607 5.598549 555.714038-0.098662 510.536154 0.001289 222.37722 0.700947-7.41029 237.38508 0.185992 525.444064c7.096526 271.667008 225.889418 490.559851 497.456474 497.856279 287.559228 7.796183 524.14341-220.891864 525.842579-508.551044 0.299853-44.977981-5.297407-88.656599-15.992171-130.236244z m-83.15929 301.552378c-22.588942 53.27392-54.873137 101.250434-95.953027 142.330323-41.179841 41.179841-89.056403 73.464036-142.330324 95.953027-55.172991 23.288599-113.744317 35.182777-174.314666 35.182777s-119.141675-11.794226-174.314666-35.182777c-53.27392-22.588942-101.250434-54.873137-142.330323-95.953027-41.179841-41.179841-73.464036-89.056403-95.953027-142.330323C75.749001 630.892442 63.954774 572.221164 63.954774 511.750767s11.794226-119.141675 35.182777-174.314666c22.588942-53.27392 54.873137-101.250434 95.953027-142.330323 41.179841-41.179841 89.056403-73.464036 142.330323-95.953027C392.593892 75.7642 451.26517 63.969974 511.735567 63.969974c13.99315 0 27.886348 0.599706 41.679596 1.89907C489.246577 118.643209 448.266638 198.704016 448.266638 288.360126c0 159.022152 128.836929 287.859081 287.859081 287.859081 89.156354 0 168.817357-40.580134 221.691473-104.149015 1.099462 13.09359 1.699168 26.387082 1.699168 39.680575 0 60.470397-11.794226 119.141675-35.182776 174.314666z" p-id="5087" fill="#6c757d"></path></svg></a></div>
        
    </div>

    
</div>

    
    
</div>
</div>
        <div id="content">















<div class="container-main 
     container-search 
    ">

    <div class="desc">
        
    </div>
    
    <div class="toc">
        
        <nav id="TableOfContents"></nav>
    </div>

    <div class='content  content '>
        
    </div>

    <div class="container-search">
    <div id="data" style="display: none;">
        
            
                [{"content":"","date":"2023-06-30","permalink":"https://idiots-dream.github.io/posts/wiki/","summary":"","title":"百科全书"},{"content":" go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。\n类型别名和自定义类型 自定义类型 在go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，go语言中可以使用type关键字来定义自定义类型。\n自定义类型是定义了一个全新的类型。可以基于内置的基本类型定义，也可以通过struct定义。例如：\n// 将myint定义为int类型 type myint int 通过 type 关键字的定义，myint就是一种新的类型，它具有int的特性。\n类型别名 类型别名是go1.9版本添加的新功能。\n类型别名规定：typealias只是type的别名，本质上typealias与type是同一个类型\ntype typealias = type rune和byte就是类型别名，定义如下：\ntype byte = uint8 type rune = int32 类型定义和类型别名的区别 类型别名与类型定义表面上看只有一个等号的差异\n//类型定义 type newint int //类型别名 type myint = int func main() { var a newint var b myint fmt.printf(\u0026#34;type of a:%t\\n\u0026#34;, a) //type of a:main.newint fmt.printf(\u0026#34;type of b:%t\\n\u0026#34;, b) //type of b:int } /* 结果显示a的类型是 main.newint，表示main包下定义的newint类型。 b的类型是int。myint类型只会在代码中存在，编译完成时并不会有myint类型 */ 结构体 go语言中的基础数据类型可以表示一些事物的基本属性，但是想表达一个事物的全部或部分属性时，再用单一的基本数据类型明显就无法满足需求了，go语言提供了一种自定义数据类型，可以封装多个基本数据类型，叫结构体，英文名称struct。 也就可以通过struct来定义类型\ngo语言中通过struct来实现面向对象\n结构体定义 type 类型名 struct { 字段名 字段类型 字段名 字段类型 ... } /* 类型名：标识自定义结构体的名称，在同一个包内不能重复。 字段名：表示结构体字段名。结构体中的字段名必须唯一。 字段类型：表示结构体字段的具体类型。 */ type person struct { name string city string age int8 } 语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。本质上是一种聚合型的数据类型\n结构体实例化 只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。\n结构体本身也是一种类型，可以像声明内置类型一样使用var关键字声明结构体类型。\nvar 结构体实例 结构体类型 type person struct { name string city string age int8 } func main() { var p1 person p1.name = \u0026#34;pprof.cn\u0026#34; p1.city = \u0026#34;北京\u0026#34; p1.age = 18 fmt.printf(\u0026#34;p1=%v\\n\u0026#34;, p1) // p1={pprof.cn 北京 18} fmt.printf(\u0026#34;p1=%#v\\n\u0026#34;, p1) // p1=main.person{name:\u0026#34;pprof.cn\u0026#34;, city:\u0026#34;北京\u0026#34;, age:18} } // 通过.来访问结构体的字段（成员变量） 匿名结构体 定义一些临时数据结构等场景下可以使用匿名结构体\nfunc main() { var user struct{name string; age int} user.name = \u0026#34;pprof.cn\u0026#34; user.age = 18 fmt.printf(\u0026#34;%#v\\n\u0026#34;, user) } 创建指针类型结构体 可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址\nvar p2 = new(person) fmt.printf(\u0026#34;%t\\n\u0026#34;, p2) // *main.person，p2是一个结构体指针 fmt.printf(\u0026#34;p2=%#v\\n\u0026#34;, p2) // p2=\u0026amp;main.person{name:\u0026#34;\u0026#34;, city:\u0026#34;\u0026#34;, age:0}，在go语言中支持对结构体指针直接使用.来访问结构体的成员 取结构体的地址实例化 使用\u0026amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作\np3 := \u0026amp;person{} fmt.printf(\u0026#34;%t\\n\u0026#34;, p3) //*main.person fmt.printf(\u0026#34;p3=%#v\\n\u0026#34;, p3) //p3=\u0026amp;main.person{name:\u0026#34;\u0026#34;, city:\u0026#34;\u0026#34;, age:0} p3.name = \u0026#34;博客\u0026#34; p3.age = 30 p3.city = \u0026#34;成都\u0026#34; fmt.printf(\u0026#34;p3=%#v\\n\u0026#34;, p3) //p3=\u0026amp;main.person{name:\u0026#34;博客\u0026#34;, city:\u0026#34;成都\u0026#34;, age:30} p3.name = \u0026ldquo;博客\u0026quot;其实在底层是(*p3).name = \u0026ldquo;博客\u0026rdquo;，是go语言实现的语法糖。\n结构体初始化 type person struct { name string city string age int8 } func main() { var p4 person fmt.printf(\u0026#34;p4=%#v\\n\u0026#34;, p4) //p4=main.person{name:\u0026#34;\u0026#34;, city:\u0026#34;\u0026#34;, age:0} } 使用键值对初始化 使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。\np5 := person{ name: \u0026#34;pprof.cn\u0026#34;, city: \u0026#34;北京\u0026#34;, age: 18, } fmt.printf(\u0026#34;p5=%#v\\n\u0026#34;, p5) //p5=main.person{name:\u0026#34;pprof.cn\u0026#34;, city:\u0026#34;北京\u0026#34;, age:18} 也可以对结构体指针进行键值对初始化，例如：\np6 := \u0026amp;person{ name: \u0026#34;pprof.cn\u0026#34;, city: \u0026#34;北京\u0026#34;, age: 18, } fmt.printf(\u0026#34;p6=%#v\\n\u0026#34;, p6) //p6=\u0026amp;main.person{name:\u0026#34;pprof.cn\u0026#34;, city:\u0026#34;北京\u0026#34;, age:18} 当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值\np7 := \u0026amp;person{ city: \u0026#34;北京\u0026#34;, } fmt.printf(\u0026#34;p7=%#v\\n\u0026#34;, p7) //p7=\u0026amp;main.person{name:\u0026#34;\u0026#34;, city:\u0026#34;北京\u0026#34;, age:0} 使用值的列表初始化 初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：\np8 := \u0026amp;person{ \u0026#34;pprof.cn\u0026#34;, \u0026#34;北京\u0026#34;, 18, } fmt.printf(\u0026#34;p8=%#v\\n\u0026#34;, p8) //p8=\u0026amp;main.person{name:\u0026#34;pprof.cn\u0026#34;, city:\u0026#34;北京\u0026#34;, age:18} 使用这种格式初始化时，需要注意：\n必须初始化结构体的所有字段 初始值的填充顺序必须与字段在结构体中的声明顺序一致 该方式不能和键值初始化方式混用y 结构体内存布局 type test struct { a int8 b int8 c int8 d int8 } n := test{ 1, 2, 3, 4, } fmt.printf(\u0026#34;n.a %p\\n\u0026#34;, \u0026amp;n.a) // n.a 0xc0000a0060 fmt.printf(\u0026#34;n.b %p\\n\u0026#34;, \u0026amp;n.b) // n.b 0xc0000a0061 fmt.printf(\u0026#34;n.c %p\\n\u0026#34;, \u0026amp;n.c) // n.c 0xc0000a0062 fmt.printf(\u0026#34;n.d %p\\n\u0026#34;, \u0026amp;n.d) // n.d 0xc0000a0063 面试题 type student struct { name string age int } func main() { m := make(map[string]*student) stus := []student{ {name: \u0026#34;pprof.cn\u0026#34;, age: 18}, {name: \u0026#34;测试\u0026#34;, age: 23}, {name: \u0026#34;博客\u0026#34;, age: 28}, } for _, stu := range stus { m[stu.name] = \u0026amp;stu } for k, v := range m { fmt.println(k, \u0026#34;=\u0026gt;\u0026#34;, v.name) } } /* pprof.cn =\u0026gt; 博客 测试 =\u0026gt; 博客 博客 =\u0026gt; 博客 */ 构造函数 go语言的结构体没有构造函数，可以单独实现。因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。\n// 实现一个person的构造函数 func newperson(name, city string, age int8) *person { return \u0026amp;person{ name: name, city: city, age: age, } } 调用构造函数\np9 := newperson(\u0026#34;pprof.cn\u0026#34;, \u0026#34;测试\u0026#34;, 90) fmt.printf(\u0026#34;%#v\\n\u0026#34;, p9) 方法和接收者 go语言中的方法（method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（receiver）。接收者的概念就类似于其他语言中的this或者 self。\n方法的定义格式如下：\nfunc (接收者变量 接收者类型) 方法名(参数列表) (返回参数) { // 函数体 } /* 1.接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。 - 例如，person类型的接收者变量应该命名为 p，connector类型的接收者变量应该命名为c等。 2.接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。 3.方法名、参数列表、返回参数：具体格式与函数定义相同。 */ 举个例子：\n//person 结构体 type person struct { name string age int8 } //newperson 构造函数 func newperson(name string, age int8) *person { return \u0026amp;person{ name: name, age: age, } } //dream person做梦的方法 func (p person) dream() { fmt.printf(\u0026#34;%s的梦想是学好go语言！\\n\u0026#34;, p.name) } func main() { p1 := newperson(\u0026#34;测试\u0026#34;, 25) p1.dream() } 方法与函数的区别是，函数不属于任何类型，方法属于特定的类型\n指针类型的接收者 指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如为person添加一个setage方法，来修改实例变量的年龄。\n// setage 设置p的年龄 // 使用指针接收者 func (p *person) setage(newage int8) { p.age = newage } func main() { p1 := newperson(\u0026#34;测试\u0026#34;, 25) fmt.println(p1.age) // 25 p1.setage(30) // 调用方法 fmt.println(p1.age) // 30 } 值类型的接收者 当方法作用于值类型接收者时，go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。\n// setage2 设置p的年龄 // 使用值接收者 func (p person) setage2(newage int8) { p.age = newage } func main() { p1 := newperson(\u0026#34;测试\u0026#34;, 25) p1.dream() fmt.println(p1.age) // 25 p1.setage2(30) // (*p1).setage2(30) fmt.println(p1.age) // 25 } 什么时候使用指针类型接收者 1.需要修改接收者中的值\r2.接收者是拷贝代价比较大的大对象\r3.保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。 任意类型添加方法 在go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，基于内置的int类型使用type关键字可以定义新的自定义类型，然后为自定义类型添加方法。\n//myint 将int定义为自定义myint类型 type myint int //sayhello 为myint添加一个sayhello的方法 func (m myint) sayhello() { fmt.println(\u0026#34;hello, 我是一个int。\u0026#34;) } func main() { var m1 myint m1.sayhello() //hello, 我是一个int。 m1 = 100 fmt.printf(\u0026#34;%#v %t\\n\u0026#34;, m1, m1) //100 main.myint } 注意事项： 非本地类型不能定义方法，也就是说不能给别的包的类型定义方法。\n结构体的匿名字段 结构体允许其成员字段在声明时没有字段名而只有类型，没有名字的字段就称为匿名字段。匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。\n//person 结构体person类型 type person struct { string int } func main() { p1 := person{ \u0026#34;pprof.cn\u0026#34;, 18, } fmt.printf(\u0026#34;%#v\\n\u0026#34;, p1) //main.person{string:\u0026#34;pprof.cn\u0026#34;, int:18} fmt.println(p1.string, p1.int) //pprof.cn 18 } 嵌套结构体 一个结构体中可以嵌套包含另一个结构体或结构体指针\n//address 地址结构体 type address struct { province string city string } //user 用户结构体 type user struct { name string gender string address address } func main() { user1 := user{ name: \u0026#34;pprof\u0026#34;, gender: \u0026#34;女\u0026#34;, address: address{ province: \u0026#34;黑龙江\u0026#34;, city: \u0026#34;哈尔滨\u0026#34;, }, } fmt.printf(\u0026#34;user1=%#v\\n\u0026#34;, user1)//user1=main.user{name:\u0026#34;pprof\u0026#34;, gender:\u0026#34;女\u0026#34;, address:main.address{province:\u0026#34;黑龙江\u0026#34;, city:\u0026#34;哈尔滨\u0026#34;}} } 嵌套匿名结构体 //address 地址结构体 type address struct { province string city string } //user 用户结构体 type user struct { name string gender string address //匿名结构体 } func main() { var user2 user user2.name = \u0026#34;pprof\u0026#34; user2.gender = \u0026#34;女\u0026#34; user2.address.province = \u0026#34;黑龙江\u0026#34; //通过匿名结构体.字段名访问 user2.city = \u0026#34;哈尔滨\u0026#34; //直接访问匿名结构体的字段名 fmt.printf(\u0026#34;user2=%#v\\n\u0026#34;, user2) // user2=main.user{name:\u0026#34;pprof\u0026#34;, gender:\u0026#34;女\u0026#34;, address:main.address{province:\u0026#34;黑龙江\u0026#34;, city:\u0026#34;哈尔滨\u0026#34;}} } 当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。\n嵌套结构体的字段名冲突 嵌套结构体内部可能存在相同的字段名。为了避免歧义需要指定具体的内嵌结构体的字段。\n//address 地址结构体 type address struct { province string city string createtime string } //email 邮箱结构体 type email struct { account string createtime string } //user 用户结构体 type user struct { name string gender string address email } func main() { var user3 user user3.name = \u0026#34;pprof\u0026#34; user3.gender = \u0026#34;女\u0026#34; // user3.createtime = \u0026#34;2019\u0026#34; //ambiguous selector user3.createtime user3.address.createtime = \u0026#34;2000\u0026#34; //指定address结构体中的createtime user3.email.createtime = \u0026#34;2000\u0026#34; //指定email结构体中的createtime } 结构体的“继承” go语言中使用结构体也可以实现其他编程语言中面向对象的继承。\n//animal 动物 type animal struct { name string } func (a *animal) move() { fmt.printf(\u0026#34;%s会动！\\n\u0026#34;, a.name) } //dog 狗 type dog struct { feet int8 *animal // 通过嵌套匿名结构体实现继承 } func (d *dog) wang() { fmt.printf(\u0026#34;%s会汪汪汪~\\n\u0026#34;, d.name) } func main() { d1 := \u0026amp;dog{ feet: 4, animal: \u0026amp;animal{ // 注意嵌套的是结构体指针 name: \u0026#34;乐乐\u0026#34;, }, } d1.wang() // 乐乐会汪汪汪~ d1.move() // 乐乐会动！ } 结构体字段的可见性 结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。\n结构体与json序列化 json(javascript object notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。json键值对是用来保存js对象的一种方式，键/值对组合中的键名写在前面并用双引号\u0026quot;\u0026ldquo;包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。\n//student 学生 type student struct { id int gender string name string } //class 班级 type class struct { title string students []*student } func main() { c := \u0026amp;class{ title: \u0026#34;101\u0026#34;, students: make([]*student, 0, 200), } for i := 0; i \u0026lt; 10; i++ { stu := \u0026amp;student{ name: fmt.sprintf(\u0026#34;stu%02d\u0026#34;, i), gender: \u0026#34;男\u0026#34;, id: i, } c.students = append(c.students, stu) } //json序列化：结构体--\u0026gt;json格式的字符串 data, err := json.marshal(c) if err != nil { fmt.println(\u0026#34;json marshal failed\u0026#34;) return } fmt.printf(\u0026#34;json:%s\\n\u0026#34;, data) //json反序列化：json格式的字符串--\u0026gt;结构体 str := `{\u0026#34;title\u0026#34;:\u0026#34;101\u0026#34;,\u0026#34;students\u0026#34;:[{\u0026#34;id\u0026#34;:0,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;stu00\u0026#34;},{\u0026#34;id\u0026#34;:1,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;stu01\u0026#34;},{\u0026#34;id\u0026#34;:2,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;stu02\u0026#34;},{\u0026#34;id\u0026#34;:3,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;stu03\u0026#34;},{\u0026#34;id\u0026#34;:4,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;stu04\u0026#34;},{\u0026#34;id\u0026#34;:5,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;stu05\u0026#34;},{\u0026#34;id\u0026#34;:6,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;stu06\u0026#34;},{\u0026#34;id\u0026#34;:7,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;stu07\u0026#34;},{\u0026#34;id\u0026#34;:8,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;stu08\u0026#34;},{\u0026#34;id\u0026#34;:9,\u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;stu09\u0026#34;}]}` c1 := \u0026amp;class{} err = json.unmarshal([]byte(str), c1) if err != nil { fmt.println(\u0026#34;json unmarshal failed!\u0026#34;) return } fmt.printf(\u0026#34;%#v\\n\u0026#34;, c1) } 结构体标签（tag） tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。\ntag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式：\n`key1:\u0026#34;value1\u0026#34; key2:\u0026#34;value2\u0026#34;` 结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。\n注意事项： 为结构体编写tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。\n例如：为student结构体的每个字段定义json序列化时使用的tag：\n//student 学生 type student struct { id int `json:\u0026#34;id\u0026#34;` //通过指定tag实现json序列化该字段时的key gender string //json序列化是默认使用字段名作为key name string //私有不能被json包访问 } func main() { s1 := student{ id: 1, gender: \u0026#34;女\u0026#34;, name: \u0026#34;pprof\u0026#34;, } data, err := json.marshal(s1) if err != nil { fmt.println(\u0026#34;json marshal failed!\u0026#34;) return } fmt.printf(\u0026#34;json str:%s\\n\u0026#34;, data) //json str:{\u0026#34;id\u0026#34;:1,\u0026#34;gender\u0026#34;:\u0026#34;女\u0026#34;} } 小练习 猜一下下列代码运行的结果是什么\npackage main import \u0026#34;fmt\u0026#34; type student struct { id int name string age int } func demo(ce []student) { //切片是引用传递，是可以改变值的 ce[1].age = 999 // ce = append(ce, student{3, \u0026#34;xiaowang\u0026#34;, 56}) // return ce } func main() { var ce []student //定义一个切片类型的结构体 ce = []student{ student{1, \u0026#34;xiaoming\u0026#34;, 22}, student{2, \u0026#34;xiaozhang\u0026#34;, 33}, } fmt.println(ce) // [{1 xiaoming 22} {2 xiaozhang 33}] demo(ce) fmt.println(ce) // [{1 xiaoming 22} {2 xiaozhang 999}] } 删除map类型的结构体 package main import \u0026#34;fmt\u0026#34; type student struct { id int name string age int } func main() { ce := make(map[int]student) ce[1] = student{1, \u0026#34;xiaolizi\u0026#34;, 22} ce[2] = student{2, \u0026#34;wang\u0026#34;, 23} fmt.println(ce) delete(ce, 2) fmt.println(ce) } 实现map有序输出(面试经常问到) package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sort\u0026#34; ) func main() { map1 := make(map[int]string, 5) map1[1] = \u0026#34;www.topgoer.com\u0026#34; map1[2] = \u0026#34;rpc.topgoer.com\u0026#34; map1[5] = \u0026#34;ceshi\u0026#34; map1[3] = \u0026#34;xiaohong\u0026#34; map1[4] = \u0026#34;xiaohuang\u0026#34; sli := []int{} for k, _ := range map1 { sli = append(sli, k) } sort.ints(sli) for i := 0; i \u0026lt; len(map1); i++ { fmt.println(map1[sli[i]]) } } 面向对象 匿名字段 go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段\npackage main import \u0026#34;fmt\u0026#34; // go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段 //人 type person struct { name string sex string age int } type student struct { person id int addr string } func main() { // 初始化 s1 := student{person{\u0026#34;5lmh\u0026#34;, \u0026#34;man\u0026#34;, 20}, 1, \u0026#34;bj\u0026#34;} fmt.println(s1) // {{5lmh man 20} 1 bj} s2 := student{person: person{\u0026#34;5lmh\u0026#34;, \u0026#34;man\u0026#34;, 20}} fmt.println(s2) // {{5lmh man 20} 0 } s3 := student{person: person{name: \u0026#34;5lmh\u0026#34;}} fmt.println(s3) // {{5lmh 0} 0 } } 同名字段的情况\npackage main import \u0026#34;fmt\u0026#34; //人 type person struct { name string sex string age int } type student struct { person id int addr string //同名字段 name string } func main() { var s student // 给自己字段赋值了 s.name = \u0026#34;5lmh\u0026#34; fmt.println(s) // {{ 0} 0 5lmh} // 若给父类同名字段赋值，如下 s.person.name = \u0026#34;枯藤\u0026#34; fmt.println(s) // {{枯藤 0} 0 5lmh} } 所有的内置类型和自定义类型都是可以作为匿名字段去使用\npackage main import \u0026#34;fmt\u0026#34; //人 type person struct { name string sex string age int } // 自定义类型 type mystr string // 学生 type student struct { person int mystr } func main() { s1 := student{person{\u0026#34;5lmh\u0026#34;, \u0026#34;man\u0026#34;, 18}, 1, \u0026#34;bj\u0026#34;} fmt.println(s1) // {{5lmh man 18} 1 bj} } 指针类型匿名字段\npackage main import \u0026#34;fmt\u0026#34; //人 type person struct { name string sex string age int } // 学生 type student struct { *person id int addr string } func main() { s1 := student{\u0026amp;person{\u0026#34;5lmh\u0026#34;, \u0026#34;man\u0026#34;, 18}, 1, \u0026#34;bj\u0026#34;} fmt.println(s1) // {0xc00005c360 1 bj} fmt.println(s1.name) // zs fmt.println(s1.person.name) // zs } 接口 接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。\n接口类型 在go语言中接口（interface）是一种类型，一种抽象的类型。\ninterface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。\n为了保护你的go语言职业生涯，请牢记接口（interface）是一种类型。\n为什么要使用接口 type cat struct{} func (c cat) say() string { return \u0026#34;喵喵喵\u0026#34; } type dog struct{} func (d dog) say() string { return \u0026#34;汪汪汪\u0026#34; } func main() { c := cat{} fmt.println(\u0026#34;猫:\u0026#34;, c.say()) d := dog{} fmt.println(\u0026#34;狗:\u0026#34;, d.say()) } 上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？\n像类似的例子在我们编程过程中会经常遇到：\n比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？\n比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？\n比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？\ngo语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。\n接口的定义 go语言提倡面向接口编程。\n接口是一个或多个方法签名的集合。\r任何类型的方法集中只要拥有该接口\u0026#39;对应的全部方法\u0026#39;签名。\r就表示它 \u0026#34;实现\u0026#34; 了该接口，无须在该类型上显式声明实现了哪个接口。\r这称为structural typing。\r所谓对应方法，是指有相同名称、参数列表 (不包括参数名) 以及返回值。\r当然，该类型还可以有其他方法。\r接口只有方法声明，没有实现，没有数据字段。\r接口可以匿名嵌入其他接口，或嵌入到结构中。\r对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。\r只有当接口存储的类型和对象都为nil时，接口才等于nil。\r接口调用不会做receiver的自动转换。\r接口同样支持匿名字段方法。\r接口也可实现类似oop中的多态。\r空接口可以作为任何类型数据的容器。\r一个类型可实现多个接口。\r接口命名习惯以 er 结尾。 每个接口由数个方法组成，接口的定义格式如下：\ntype 接口类型名 interface{ // 方法名1( 参数列表1 ) 返回值列表1 // 方法名2( 参数列表2 ) 返回值列表2 } /* 1.接口名：使用type将接口定义为自定义的类型名。 - go语言的接口在命名时，一般会在单词后面添加er，接口名最好要能突出该接口的类型含义。 2.方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。 3.参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。 */ 举个例子：\ntype writer interface{ write([]byte) error } 实现接口的条件 一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。\n定义一个sayer接口：\n// sayer 接口 type sayer interface { say() } 定义dog和cat两个结构体：\ntype dog struct {} type cat struct {} 因为sayer接口里只有一个say方法，所以只需要给dog和cat分别实现say方法就可以实现sayer接口了。\n// dog实现了sayer接口 func (d dog) say() { fmt.println(\u0026#34;汪汪汪\u0026#34;) } // cat实现了sayer接口 func (c cat) say() { fmt.println(\u0026#34;喵喵喵\u0026#34;) } 接口类型变量 接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，sayer类型的变量能够存储dog和cat类型的变量。\nfunc main() { var x sayer // 声明一个sayer类型的变量x a := cat{} // 实例化一个cat b := dog{} // 实例化一个dog x = a // 可以把cat实例直接赋值给x x.say() // 喵喵喵 x = b // 可以把dog实例直接赋值给x x.say() // 汪汪汪 } 值接收者和指针接收者实现接口的区别 使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。\n有一个mover接口和一个dog结构体。\ntype mover interface { move() } type dog struct {} 值接收者实现接口 func (d dog) move() { fmt.println(\u0026#34;狗会动\u0026#34;) } 此时实现接口的是dog类型：\nfunc main() { var x mover var wangcai = dog{} // 旺财是dog类型 x = wangcai // x可以接收dog类型 var fugui = \u0026amp;dog{} // 富贵是*dog类型 x = fugui // x可以接收*dog类型 x.move() } 使用值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。因为go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值*fugui。\n指针接收者实现接口 同样的代码我们再来测试一下使用指针接收者有什么区别：\nfunc (d *dog) move() { fmt.println(\u0026#34;狗会动\u0026#34;) } func main() { var x mover var wangcai = dog{} // 旺财是dog类型 x = wangcai // x不可以接收dog类型 var fugui = \u0026amp;dog{} // 富贵是*dog类型 x = fugui // x可以接收*dog类型 } 此时实现mover接口的是*dog类型，所以不能给x传入dog类型的wangcai，此时x只能存储*dog类型的值。\n下面的代码是一个比较好的面试题 请问下面的代码是否能通过编译？\ntype people interface { speak(string) string } type student struct{} func (stu *stduent) speak(think string) (talk string) { if think == \u0026#34;sb\u0026#34; { talk = \u0026#34;你是个大帅比\u0026#34; } else { talk = \u0026#34;您好\u0026#34; } return } func main() { var peo people = student{} think := \u0026#34;bitch\u0026#34; fmt.println(peo.speak(think)) } 类型与接口的关系 一个类型实现多个接口 一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义sayer接口和mover接口，如下： mover接口。\n// sayer 接口 type sayer interface { say() } // mover 接口 type mover interface { move() } dog既可以实现sayer接口，也可以实现mover接口。\ntype dog struct { name string } // 实现sayer接口 func (d dog) say() { fmt.printf(\u0026#34;%s会叫汪汪汪\\n\u0026#34;, d.name) } // 实现mover接口 func (d dog) move() { fmt.printf(\u0026#34;%s会动\\n\u0026#34;, d.name) } func main() { var x sayer var y mover var a = dog{name: \u0026#34;旺财\u0026#34;} x = a y = a x.say() y.move() } 多个类型实现同一接口 go语言中不同的类型还可以实现同一接口 首先我们定义一个mover接口，它要求必须由一个move方法。\n// mover 接口 type mover interface { move() } 例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系：\ntype dog struct { name string } type car struct { brand string } // dog类型实现mover接口 func (d dog) move() { fmt.printf(\u0026#34;%s会跑\\n\u0026#34;, d.name) } // car类型实现mover接口 func (c car) move() { fmt.printf(\u0026#34;%s速度70迈\\n\u0026#34;, c.brand) } 这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的move方法就可以了。\nfunc main() { var x mover var a = dog{name: \u0026#34;旺财\u0026#34;} var b = car{brand: \u0026#34;保时捷\u0026#34;} x = a x.move() x = b x.move() } 上面的代码执行结果如下：\n旺财会跑\r保时捷速度70迈 并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。\n// washingmachine 洗衣机 type washingmachine interface { wash() dry() } // 甩干器 type dryer struct{} // 实现washingmachine接口的dry()方法 func (d dryer) dry() { fmt.println(\u0026#34;甩一甩\u0026#34;) } // 海尔洗衣机 type haier struct { dryer //嵌入甩干器 } // 实现washingmachine接口的wash()方法 func (h haier) wash() { fmt.println(\u0026#34;洗刷刷\u0026#34;) } 接口嵌套 接口与接口间可以通过嵌套创造出新的接口。\n// sayer 接口 type sayer interface { say() } // mover 接口 type mover interface { move() } // 接口嵌套 type animal interface { sayer mover } 嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：\ntype cat struct { name string } func (c cat) say() { fmt.println(\u0026#34;喵喵喵\u0026#34;) } func (c cat) move() { fmt.println(\u0026#34;猫会动\u0026#34;) } func main() { var x animal x = cat{name: \u0026#34;花花\u0026#34;} x.move() x.say() } 空接口 空接口的定义 空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。\n空接口类型的变量可以存储任意类型的变量。\nfunc main() { // 定义一个空接口x var x interface{} s := \u0026#34;pprof.cn\u0026#34; x = s fmt.printf(\u0026#34;type:%t value:%v\\n\u0026#34;, x, x) i := 100 x = i fmt.printf(\u0026#34;type:%t value:%v\\n\u0026#34;, x, x) b := true x = b fmt.printf(\u0026#34;type:%t value:%v\\n\u0026#34;, x, x) } 空接口的应用 空接口作为函数的参数 使用空接口实现可以接收任意类型的函数参数。\n// 空接口作为函数参数 func show(a interface{}) { fmt.printf(\u0026#34;type:%t value:%v\\n\u0026#34;, a, a) } 空接口作为map的值 使用空接口实现可以保存任意值的字典。\n// 空接口作为map值 var studentinfo = make(map[string]interface{}) studentinfo[\u0026#34;name\u0026#34;] = \u0026#34;李白\u0026#34; studentinfo[\u0026#34;age\u0026#34;] = 18 studentinfo[\u0026#34;married\u0026#34;] = false fmt.println(studentinfo) 类型断言 空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？\n接口值 一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。\n我们来看一个具体的例子：\nvar w io.writer w = os.stdout w = new(bytes.buffer) w = nil 请看下图分解：\n想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：\nx.(t) 其中：\nx：表示类型为interface{}的变量\rt：表示断言x可能是的类型。 该语法返回两个参数，第一个参数是x转化为t类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败。\n举个例子：\nfunc main() { var x interface{} x = \u0026#34;pprof.cn\u0026#34; v, ok := x.(string) if ok { fmt.println(v) } else { fmt.println(\u0026#34;类型断言失败\u0026#34;) } } 上面的示例中如果要断言多次就需要写多个if判断，这个时候我们可以使用switch语句来实现：\nfunc justifytype(x interface{}) { switch v := x.(type) { case string: fmt.printf(\u0026#34;x is a string，value is %v\\n\u0026#34;, v) case int: fmt.printf(\u0026#34;x is a int is %v\\n\u0026#34;, v) case bool: fmt.printf(\u0026#34;x is a bool is %v\\n\u0026#34;, v) default: fmt.println(\u0026#34;unsupport type！\u0026#34;) } } 因为空接口可以存储任意类型值的特点，所以空接口在go语言中的使用十分广泛。\n关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。\n","date":"2023-06-30","permalink":"https://idiots-dream.github.io/posts/golang/struct/","summary":"Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。 类型别名和自定义类型 自","title":"golang 结构体"},{"content":"golang 基础知识 数据类型 数字类型 整数类型（int） go语言中int类型的大小是不确定的，与具体的平台有关系，一般来说，int在32位系统中是4字节，在64位系统中是8字节，使用自动推导类型初始化一个整数，默认为int类型。\n由于go语言中各 int 类型的取值范围不同，各int类型间进行数据转换时，会存在数据截断的问题，在使用过程中要引起注意。\n类型 描述 uint8 无符号 8 位整型 (0 到 255) uint16 无符号 16 位整型 (0 到 65535) uint32 无符号 32 位整型 (0 到 4294967295) uint64 无符号 64 位整型 (0 到 18446744073709551615) int8 有符号 8 位整型 (-128 到 127) int16 有符号 16 位整型 (-32768 到 32767) int32 有符号 32 位整型 (-2147483648 到 2147483647) int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点类型（float） 类型 说明 float32 ieee-754 32位浮点型数 float64 ieee-754 64位浮点型数 complex64 32 位实数和虚数 complex128 64 位实数和虚数 字符串类型 字符串就是一串固定长度的字符使用双引号（\u0026quot;\u0026quot;）连接起来的字符序列。\ngo 的字符串是由单个字节连接起来的。go 语言的字符串的字节使用 utf-8 编码标识 unicode 文本\n方法 介绍 len(str) 求长度 +或fmt.sprintf 拼接字符串 strings.split 分割 strings.contains 判断是否包含 strings.hasprefix,strings.hassuffix 前缀/后缀判断 strings.index(),strings.lastindex() 子串出现的位置 strings.join(a[]string, sep string) join操作 byte和rune类型 组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来\ngo 语言的字符有以下两种：\nuint8类型：(或叫 byte 型)，代表了ascii码的一个字符。 rune类型：代表一个 utf-8字符。rune类型实际是一个int32， go 使用了特殊的 rune 类型来处理 unicode，让基于 unicode的文本处理更为方便，也可以使用 byte 型进行默认字符串处理 utf8编码下一个中文汉字由3~4个字节组成，所以不能按照字节去遍历一个包含中文的字符串\n字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的，字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。\n修改字符串 要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。都会重新分配内存，并复制字节数组。\nfunc changestring() { s1 := \u0026#34;hello\u0026#34; // 强制类型转换 bytes1 := []byte(s1) bytes1[0] = \u0026#39;h\u0026#39; fmt.println(string(bytes1)) s2 := \u0026#34;博客\u0026#34; runes2 := []rune(s2) runes2[0] = \u0026#39;狗\u0026#39; fmt.println(string(runes2)) } 类型转换 go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。\n强制转换类型语法：t(表达式)；t表示要转换的类型。表达式包括变量、复杂算子和函数返回值\n变量和常量 变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念\n变量可以通过变量名访问\n变量名命名规则 变量名由字母、数字、下划线组成，其中首个字符不能为数字\n下面对文件名命令规则的说明： 1、平台区分 文件名_平台。\n例： file_windows.go, file_unix.go\n可选为：windows, unix, posix, plan9, darwin, bsd, linux, freebsd, nacl, netbsd, openbsd, solaris, dragonfly, bsd, notbsd， android，stubs\n2、测试单元 文件名test.go或者 文件名平台_test.go。 例： path_test.go, path_windows_test.go\n3、版本区分(猜测) 文件名_版本号等。 例：trap_windows_1.4.go\n4、cpu类型区分, 汇编用的多 文件名_(平台:可选)_cpu类型. 例：vdso_linux_amd64.go 可选：amd64, none, 386, arm, arm64, mips64, s390,mips64x,ppc64x, nonppc64x, s390x, x86,amd64p32\n1、golang的命名需要使用驼峰命名法，且不能出现下划线\n2、golang中根据首字母的大小写来确定可以访问的权限。无论是方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用 可以简单的理解成，首字母大写是公有的，首字母小写是私有的\n3、结构体中属性名的大写\n如果属性名小写则在数据解析（如json解析,或将结构体作为请求或访问参数）时无法解析\n注意点一、\ngo build 的时候会选择性地编译以系统名结尾的文件(linux、darwin、windows、freebsd)。例如linux(unix)系统下编译只会选择array_linux.go文件，其它系统命名后缀文件全部忽略。\n注意点二、 在xxx.go文件的文件头上添加 // + build !windows (tags)，可以选择在windows系统下面不编译 // +build !windows package main\n总结：golang跨平台没有java好用，但是跟c语言差不多，都得针对不同平台不同特性迭轮子\n变量初始化方式 标准格式 变量声明以关键字 var 开头，后置变量类型，行尾无须分号\nvar 变量名 变量类型 批量方式 使用关键字 var 和括号，可以将一组变量定义放在一起\nvar ( a int b string ) 简短方式 除 var 关键字外，还可使用更加简短的变量定义和初始化语法\n名字 := 表达式 简短模式（short variable declaration）的限制：\n定义变量，同时显式初始化 不提供数据类型 只能用在函数内部 func main() { x:=100 a,s := 1, \u0026#34;abc\u0026#34; } 因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var 形式的声明语句往往是用于需要显式指定变量类型，或因变量会被重新赋值而初始值无关紧要的地方。\n匿名变量 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）。 匿名变量用一个下划线_表示\nfunc main() { x, _ := foo() fmt.println(\u0026#34;x=\u0026#34;, x) } 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。\n注意事项\n函数外的每个语句都必须以关键字开始（var、const、func等） :=不能使用在函数外。 _多用于占位，表示忽略值。 常量 常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。\nconst pi = 3.1415 const e = 2.7182 声明的常量，在整个程序运行期间它们的值都不能再发生变化了\nconst同时声明多个常量时，如果省略了值则表示和上面一行的值相同\nconst ( n1 = 100 n2 n3 ) // n1,n2,n3值都为100 iota iota是go语言的常量计数器，只能在常量的表达式中使用。 iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。\nconst ( n1 = iota //0 n2 //1 n3 //2 n4 //3 ) // ------------------------ const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3 ) const n5 = iota //0 // ------------------------ const ( _ = iota kb = 1 \u0026lt;\u0026lt; (10 * iota) mb = 1 \u0026lt;\u0026lt; (10 * iota) gb = 1 \u0026lt;\u0026lt; (10 * iota) tb = 1 \u0026lt;\u0026lt; (10 * iota) pb = 1 \u0026lt;\u0026lt; (10 * iota) ) 下划线 “_”是特殊标识符，用来忽略结果\n下划线在import中 在golang中，import的作用是导入其他package\nimport 下划线（如：import _ hello/imp）的作用：\n当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候并不需要把整个包都导入进来，仅仅是是希望执行init()函数而已,就可以使用 import _ 引用该包。即使用【import _ 包路径】只是引用该包。仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。\n下划线在代码中 package main import ( \u0026#34;os\u0026#34; ) func main() { buf := make([]byte, 1024) f, _ := os.open(\u0026#34;/users/***/desktop/text.txt\u0026#34;) defer f.close() for { n, _ := f.read(buf) if n == 0 { break } os.stdout.write(buf[:n]) } } 解释一\n下划线意思是忽略这个变量\n比如os.open，返回值为*os.file，error，普通写法是f,err := os.open(\u0026quot;xxxxxxx\u0026quot;)。如果此时不需要知道返回的错误值就可以用f, _ := os.open(\u0026quot;xxxxxx\u0026quot;)，如此则忽略了error变量\n解释二\n占位符，意思是那个位置本应赋给某个值，但是不需要这个值。所以就把该值赋给下划线，意思是丢掉不要。这样编译器可以更好的优化，任何类型的单个值都可以丢给下划线。这种情况是占位用的，方法返回两个结果，而只想要一个结果。那另一个就用 \u0026ldquo;_\u0026rdquo; 占位，如果用变量的话，不使用，编译器是会报错的。\n特殊函数 init()函数 go语言中init函数用于包(package)的初始化\ninit函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等 每个包可以拥有多个init函数，包的每个源文件也可以拥有多个init函数 同一个包中多个init函数的执行顺序没有明确的定义/说明 不同包的init函数执行顺序按照包导入的依赖关系决定 init函数不能被其他函数调用，而是在main函数执行之前，自动被调用 main()函数 go语言程序的默认入口函数(主函数)：func main()\ninit函数和mian函数的执行顺序：\n对同一个go文件的init()函数调用顺序是从上到下 对同一个package中不同go文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数 对于不同的package，如果不相互依赖的话，按照main包中\u0026quot;先import的后调用\u0026quot;的顺序调用其包中的init()，如果package存在依赖，则先调用最早被依赖的package中的init()，最后调用main函数。 如果init函数中使用了println()或者print()会发现在执行过程中这两个不会按照想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。 流程控制 条件判断控制 条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句\nif语句 if 语句的语法\n可省略条件表达式括号 持初始化语句，可定义代码块局部变量 代码块左 括号必须在条件表达式尾部 if 布尔表达式 { /* 在布尔表达式为 true 时执行 */ } if 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则不执行。\n*不支持三元操作符(三目运算符) \u0026ldquo;a \u0026gt; b ? a : b\u0026rdquo;。\nswitch语句 switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止\ngolang switch 分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止，可以使用fallthrough强制执行后面的case代码\nswitch var1 { case val1: // ... case val2: // ... default: // ... } 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。 可以同时测试多个可能符合条件的值，使用逗号分割：case val1, val2, val3\n注意switch后可以跟空，如上，原因是之前已经出现过number变量；如果为空，这样case就必须是表达式。\nfunc switchdemo(number int) { switch { case number \u0026gt;= 90: fmt.println(\u0026#34;优秀\u0026#34;) case number \u0026gt;= 80: fmt.println(\u0026#34;良好\u0026#34;) case number \u0026gt;= 60: fmt.println(\u0026#34;凑合\u0026#34;) default: fmt.println(\u0026#34;太搓了\u0026#34;) } } switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型\nswitch x.(type){ case type: statement(s) case type: statement(s) /* 可以定义任意个数的case */ default: /* 可选 */ statement(s) } select语句 select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行\nselect 是go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的\nselect { case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s); } /* 每个case都必须是一个通信 所有channel表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行；其他被忽略。 如果有多个case都可以运行，select会随机公平地选出一个执行。其他不会执行。 否则： 如果有default子句，则执行该语句。 如果没有default字句，select将阻塞，直到某个通信可以运行；go不会重新对channel或值进行求值。 */ func main() { var c1, c2, c3 chan int var i1, i2 int select { case i1 = \u0026lt;-c1: fmt.printf(\u0026#34;received \u0026#34;, i1, \u0026#34; from c1\\n\u0026#34;) case c2 \u0026lt;- i2: fmt.printf(\u0026#34;sent \u0026#34;, i2, \u0026#34; to c2\\n\u0026#34;) case i3, ok := (\u0026lt;-c3): // same as: i3, ok := \u0026lt;-c3 if ok { fmt.printf(\u0026#34;received \u0026#34;, i3, \u0026#34; from c3\\n\u0026#34;) } else { fmt.printf(\u0026#34;c3 is closed\\n\u0026#34;) } default: fmt.printf(\u0026#34;no communication\\n\u0026#34;) } } // 执行结果： no communication select可以监听channel的数据流动，由select开始的一个新的选择块，每个选择条件由case语句来描述\n与switch语句可以选择任何使用相等比较的条件相比，select由比较多的限制，其中最大的一条限制就是每个case语句里必须是一个io操作\nselect { // 不停的在这里检测 case \u0026lt;-chanl : // 检测有没有数据可以读 // 如果chanl成功读取到数据，则进行该case处理语句 case chan2 \u0026lt;- 1 : // 检测有没有可以写 // 如果成功向chan2写入数据，则进行该case处理语句 // 假如没有default，那么在以上两个条件都不成立的情况下，就会在此阻塞 // 一般default会不写在里面，select中的default子句总是可运行的，因为会很消耗cpu资源 default: // 如果以上都没有符合条件，那么则进行default处理流程 } 在一个select语句中，go会按顺序从头到尾评估每一个发送和接收的语句。\n如果其中的任意一个语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。 如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种可能的情况： ①如果给出了default语句，那么就会执行default的流程，同时程序的执行会从select语句后的语句中恢复。 ②如果没有default语句，那么select语句将被阻塞，直到至少有一个case可以进行下去。\nselect的使用及典型用法 select是go中的一个控制结构，类似于switch语句，用于处理异步io操作。select会监听case语句中channel的读写操作，当case中channel读写操作为非阻塞状态（即能读写）时，将会触发相应的动作。 select中的case语句必须是一个channel操作\nselect中的default子句总是可运行的。\n如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行。\n如果没有可运行的case语句，且有default语句，那么就会执行default的动作。\n如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行\n// 超时判断 //比如在下面的场景中，使用全局reschan来接受response，如果时间超过3s,reschan中还没有数据返回，则第二条case将执行 var reschan = make(chan int) // do request func test() { select { case data := \u0026lt;-reschan: dodata(data) case \u0026lt;-time.after(time.second * 3): fmt.println(\u0026#34;request time out\u0026#34;) } } func dodata(data int) { //... } // 退出 //主线程（协程）中如下： var shouldquit=make(chan struct{}) fun main(){ { //loop } //...out of the loop select { case \u0026lt;-c.shouldquit: cleanup() return default: } //... } //再另外一个协程中，如果运行遇到非法操作或不可处理的错误，就向shouldquit发送数据通知程序停止运行 close(shouldquit) // 判断channel是否阻塞 //在某些情况下是存在不希望channel缓存满了的需求的，可以用如下方法判断 ch := make (chan int, 5) //... data：=0 select { case ch \u0026lt;- data: default: //做相应操作，比如丢弃data。视需求而定 } 循环控制 for循环 for循环是一个循环控制结构，可以执行指定次数的循环\nfor init; condition; post { } - init： 赋值表达式，给控制变量赋初值； - condition： 关系表达式或逻辑表达式，循环控制条件； - post： 赋值表达式，给控制变量增量或减量。 for语句执行过程如下： ① 先对表达式 init 赋初值； ② 判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句， ③ 然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。 for condition { } for { } // 循环中条件语句永远不为 false 则会进行无限循环 range循环 golang range类似迭代器操作，返回 (索引, 值) 或 (键, 值)\nfor 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环\nfor key, value := range oldmap { newmap[key] = value } 类型 第一个值 第二个值 string index s[index] unicode, rune array/slice index s[index] map key m[key] channel element 可忽略不想要的返回值，或 \u0026quot;_\u0026quot; 这个特殊变量\nfunc main() { s := \u0026#34;abc\u0026#34; // 忽略 2nd value，支持 string/array/slice/map。 for i := range s { println(s[i]) } // 忽略 index。 for _, c := range s { println(c) } // 忽略全部返回值，仅迭代。 for range s { } m := map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2} // 返回 (key, value)。 for k, v := range m { println(k, v) } } range循环会复制对象，可以使用引用类型，底层数据不会被复制\nfunc main() { a := [3]int{0, 1, 2} for i, v := range a { // index、value 都是从复制品中取出。 if i == 0 { // 在修改前，我们先修改原数组。 a[1], a[2] = 999, 999 fmt.println(a) // 确认修改有效，输出 [0, 999, 999]。 } a[i] = v + 100 // 使用复制品中取出的 value 修改原数组。 } fmt.println(a) // 输出 [100, 101, 102]。 } 循环控制语句：控制循环体内语句的执行过程\n三个语句都可以配合标签(label)使用 标签名区分大小写，定以后若不使用会造成编译错误 continue、break配合标签(label)可用于多层循环跳出 goto是调整执行位置，与continue、break配合标签(label)的结果并不相同 ","date":"2023-06-30","permalink":"https://idiots-dream.github.io/posts/golang/basic/","summary":"Golang 基础知识 数据类型 数字类型 整数类型（int） GO语言中int类型的大小是不确定的，与具体的平台有关系，一般来说，int在32位系统中是4字节，在64位系统中是8","title":"golang 基础知识"},]
            
        
    </div>

    <div id="search">
        
        <span class="sc-icon"><img src="/imgs/icons/search.svg" width="48"> </span>
        <span id="sc-clear" onclick="clearInputVal()">✖</span>
        <input id="sc-input" oninput="search()" type="text" placeholder="here search search..." />
        <div id="sc-res"></div>
    </div>
    <script src="/js/search.js" defer></script>
</div>

    

    
    
    

    
</div>

        </div>
        <div id="footer"><div class="container-footer">
    
    <a href="//beian.miit.gov.cn" target="_blank">
        
        <span class="some">enter your icp or a interesting slogan...<span>
        
    </a>
    <a id="s" href="/secrets">&nbsp;</a>
    
</div></div>
    </body>
</html>
